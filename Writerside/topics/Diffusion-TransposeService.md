# Diffusion: TransposeService

Overview
--------

The `TransposeService` is responsible for reorganizing the matrix structure during encryption and decryption by rearranging the rows and columns of the data matrix. This is done through transposition, where rows and columns are shuffled based on a permutation derived from the key matrix. The transposition serves to further scramble the matrix data, making the encryption process more secure.

```
public class TransposeService {

    private int[] flattenKeyMatrix(byte[][] keyMatrix) {
        int[] flatKeyMatrix = new int[16];
        int index = 0;
        for (int row = 0; row < 4; row++) {
            for (int col = 0; col < 4; col++) {
                flatKeyMatrix[index++] = Byte.toUnsignedInt(keyMatrix[row][col]);
            }
        }
        return flatKeyMatrix;
    }

    private int[] generatePermutationFromKey(int[] flatKeyMatrix) {
        Integer[] indices = {0, 1, 2, 3};
        Arrays.sort(indices, Comparator.comparingInt(a -> flatKeyMatrix[a]));
        return Arrays.stream(indices).mapToInt(Integer::intValue).toArray();
    }

    public byte[][] transposeMatrix(byte[][] matrix, KeyMatrix keyMatrix) {
        byte[][] transposedMatrix = new byte[4][4];

        int[] flatKeyMatrix = flattenKeyMatrix(keyMatrix.matrix());
        int[] rowPerm = generatePermutationFromKey(flatKeyMatrix);
        int[] colPerm = generatePermutationFromKey(flatKeyMatrix);

        for (int row = 0; row < 4; row++) {
            for (int col = 0; col < 4; col++) {
                transposedMatrix[rowPerm[row]][colPerm[col]] = matrix[row][col];
            }
        }
        return transposedMatrix;
    }

    public byte[][] reverseTransposeMatrix(byte[][] matrix, KeyMatrix keyMatrix) {
        byte[][] reversedMatrix = new byte[4][4];

        int[] flatKeyMatrix = flattenKeyMatrix(keyMatrix.matrix());
        int[] rowPerm = generatePermutationFromKey(flatKeyMatrix);
        int[] colPerm = generatePermutationFromKey(flatKeyMatrix);

        for (int row = 0; row < 4; row++) {
            for (int col = 0; col < 4; col++) {
                reversedMatrix[row][col] = matrix[rowPerm[row]][colPerm[col]];
            }
        }
        return reversedMatrix;
    }
}
```

### Purpose and Role in the Encryption Service

-   **Matrix Scrambling**: Transposition is used to shuffle the rows and columns of the data matrix based on a permutation derived from the key matrix. This step adds complexity to the encryption process by altering the positions of the data without changing its values.
-   **Row and Column Reorganization**: The transposition is performed by calculating a permutation based on the values of the key matrix. The rows and columns of the data matrix are then rearranged according to this permutation, ensuring a unique transformation for each key.

### Key Concepts

-   **Matrix Transposition**: A process of rearranging the rows and columns of a matrix. In this context, the rows and columns are shuffled based on a permutation derived from the key matrix, rather than a simple mathematical transposition.
-   **Key-Dependent Permutation**: The permutation that determines how the rows and columns of the matrix are shuffled is calculated from the key matrix. This ensures that the matrix transposition is tied directly to the encryption key, making it difficult to predict or reverse without knowing the key.

### Description

-   **Objective**: Reorganize the rows and columns of the matrix during encryption to scramble the data, and reverse this process during decryption to restore the original matrix.

-   **Process**:

    1.  **Flatten the Key Matrix**:
        -   The key matrix (a 4x4 matrix) is flattened into a 1D array of 16 integers. This is done to make it easier to compute a permutation based on the key.
    2.  **Generate Permutation**:
        -   A permutation for both the rows and the columns of the matrix is generated by sorting the values in the flattened key matrix. The indices of the sorted values determine the order of the rows and columns.
        -   For example, if the first four values in the flattened key are `[42, 10, 17, 24]`, they are sorted into `[10, 17, 24, 42]`, and the corresponding indices (1, 2, 3, 0) form the row and column permutations.
    3.  **Transpose the Matrix**:
        -   The original data matrix is transposed by applying the row and column permutations. For each position in the matrix, the value is moved to a new position determined by the row and column permutations. This results in a shuffled version of the original matrix.
    4.  **Reverse the Transposition**:
        -   During decryption, the same process is applied in reverse to restore the original matrix. The same key is used to generate the row and column permutations, and the values are moved back to their original positions in the matrix.

### Example

Let's assume the following matrix after the transformation service:

`Matrix Before Transposition:
[42, 15, 22, 37]
[60, 128, 90, 44]
[17, 99, 77, 64]
[255, 45, 33, 21]`

And the key matrix:

`Key Matrix:
[137, 20, 30, 50]
[10,  11, 9,  3]
[60,  10, 33, 22]
[19,  5,  89, 70]`

Step 1: **Flatten the Key Matrix**:

`Flattened Key Matrix:
[137, 20, 30, 50, 10, 11, 9, 3, 60, 10, 33, 22, 19, 5, 89, 70]`

Step 2: **Generate Row and Column Permutation**:

-   Row permutation (sorting the first four values): `[1, 2, 3, 0]`
-   Column permutation (sorting the first four values): `[1, 2, 3, 0]`

Step 3: **Transpose the Matrix**:

`Transposed Matrix:
[128, 90, 44, 60]
[99, 77, 64, 17]
[45, 33, 21, 255]
[15, 22, 37, 42]`

During decryption, the process is reversed, and the matrix is restored to its original form.

### Matrix Operations Explained

-   **Flattening the Key Matrix**:
    -   The key matrix is converted into a 1D array of integers to allow for sorting and permutation generation.
-   **Permutation Generation**:
    -   The values in the flattened key matrix are sorted, and the indices of the sorted values determine the order of the rows and columns in the permutation.
-   **Row and Column Transposition**:
    -   The original matrix is shuffled by rearranging its rows and columns according to the generated permutation. This scrambles the positions of the matrix values without altering their actual byte values.
-   **Reversibility**:
    -   The transposition can be reversed by applying the same permutation during decryption, restoring the original order of the matrix values.

### Role in the Encryption Workflow

-   **During Encryption**:
    -   After the transformation service, the matrix is transposed to further obscure the data. This step ensures that even if an attacker has partial knowledge of the data matrix, the shuffled rows and columns make it difficult to decipher.
-   **During Decryption**:
    -   The transposition is reversed to restore the original order of the matrix before applying further decryption steps.

### Integration in the Encryption Service

-   **Matrix Transposition Layer**:

    -   The `transposeMatrix` function adds a layer of security by altering the structure of the matrix. The transposition is dependent on the key, meaning that only the correct key can reverse the transposition and allow decryption to proceed.
-   **Reversibility and Consistency**:

    -   The transposition is fully reversible, ensuring that the decryption process can restore the matrix to its original form using the same key-based permutation that was applied during encryption.
-   **Security Benefits**:

    -   By introducing a key-dependent row and column shuffle, the transposition adds another dimension of complexity to the encryption process, making it significantly harder to reverse-engineer without the correct key.
