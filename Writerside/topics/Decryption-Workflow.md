# Decryption Workflow

Overview
--------

The `DecryptionService` class handles the reversal of the encryption process, enabling the recovery of plaintext from ciphertext. The decryption process involves reversing the series of cryptographic transformations applied during encryption, including reversing CBC, matrix transformations (bit shifting, transposition), XOR, and applying the inverse S-Box.

Key Components Involved
-----------------------

-   **Key Generation**: The decryption key sequence is generated by reversing the key evolution process from encryption.
-   **Cipher Block Chaining (CBC)**: The chaining between matrix blocks is reversed, ensuring that each block is correctly decrypted based on the previous block.
-   **Inverse S-Box Substitution**: The inverse of the S-Box transformation is applied to revert the non-linearity added during encryption.
-   **XOR Operations**: XORing with the key matrix undoes the confusion introduced during encryption.
-   **Matrix Transformations**: Reverse bit-shifting and matrix transposition operations are applied to undo the diffusion of data.

Workflow Explanation
--------------------

### 1\. **Decode the Ciphertext**

The ciphertext is first Base64-decoded and converted back into its 3D matrix form. This matrix represents the blocks of the encrypted text that need to be decrypted.

`byte[] decodedCiphertext = Base64.getUrlDecoder().decode(ciphertext);
byte[][][] cipherMatrixChunks = StringToBitstream.byteArrayToMatrixChunks(decodedCiphertext);`

### 2\. **Rebuild the Key Matrix**

The `clientKey`, which was used during encryption, is provided in hexadecimal format. This hex string is converted back into the original key matrix. This matrix contains the first byte, which indicates how many rounds of encryption were performed.

`byte[] byteArray = hexToByteArray(clientKey);
KeyMatrix decodedKey = KeyMatrix.rebuildMatrix(byteArray);
byte[] original_keyBytes = decodedKey.flattenMatrix();
int rounds = extractFirstByteAsNumber(decodedKey);`

### 3\. **Generate the Key Sequence**

The decryption process requires the same sequence of keys that were used during encryption, but in reverse order. The `applySha256ToMatrix` method from the `HashService` is used to recreate the sequence of hashed keys, starting from the original key and generating a new key for each round.

`KeyMatrix[] keySequence = new KeyMatrix[rounds + 1];
keySequence[0] = decodedKey;
for (int i = 1; i <= rounds; i++) {
    keySequence[i] = hashService.applySha256ToMatrix(keySequence[i - 1]);
}
KeyMatrix finalHashedKey = keySequence[rounds];`

### 4\. **Reverse CBC (Cipher Block Chaining)**

The reverse CBC process is applied to the ciphertext blocks. This reverses the block dependency introduced during encryption, allowing each block to be decrypted independently. The first block is XORed with the initialization vector (IV), and subsequent blocks are XORed with the previous block.

`cipherMatrixChunks = cbcService.reverseCBC(cipherMatrixChunks, finalHashedKey);`

### 5\. **Undo Transformations in Reverse Rounds**

After the CBC step, the decryption service works backwards through the rounds of encryption. For each round:

-   **Reverse Matrix Transposition**: The transposition applied during encryption is undone, restoring the original order of rows and columns in the matrix.
-   **Reverse Bit Shifting**: The bits that were shifted during encryption are shifted back to their original positions.

Both transformations are applied for every block in the matrix.

`for (int i = rounds - 1; i >= 0; i--) {
KeyMatrix currentKey = keySequence[i];

    for (int j = 0; j < cipherMatrixChunks.length; j++) {
        cipherMatrixChunks[j] = transposeService.reverseTransposeMatrix(cipherMatrixChunks[j], currentKey);
        cipherMatrixChunks[j] = transformService.performBitShift(cipherMatrixChunks[j], currentKey, false);
    }
}`

### 6\. **XOR with Key Matrix**

After the transformations, the XOR operation is applied to the matrix using the key from the current round. This undoes the confusion introduced by the XOR step in encryption, reverting the matrix closer to its original state.

`cipherMatrixChunks = xorService.xorBitstream(cipherMatrixChunks, currentKey);`

### 7\. **Apply Inverse S-Box Substitution**

The inverse S-Box is generated and applied to the matrix. This reverses the non-linearity introduced by the S-Box during encryption. Each byte in the matrix is substituted using the inverse S-Box to restore the original byte values.

`byte[] sBox = generateSBox(original_keyBytes);
byte[] inverseSBox = generateInverseSBox(sBox);
cipherMatrixChunks = sBoxService.applySBoxSubstitution(cipherMatrixChunks, inverseSBox);`

### 8\. **Reconstruct the Plaintext**

Finally, the matrix chunks are flattened back into a byte array, and the padding added during encryption is removed. The result is the original plaintext, which is converted from bytes to a UTF-8 string.

`byte[] plainBytes = StringToBitstream.matrixChunksToByteArray(cipherMatrixChunks);
return new String(plainBytes, StandardCharsets.UTF_8);`

Summary of Matrix Operations
----------------------------

-   **Initial Cipher Matrix**: The ciphertext is decoded into a 3D matrix.
-   **Reverse CBC**: The dependency between blocks is undone by XORing each block with the previous one.
-   **Matrix Transposition**: The matrix is transposed back to its original form by reversing the row and column permutations.
-   **Bit Shifting**: The bits that were shifted during encryption are shifted back.
-   **XOR with Key Matrix**: The matrix is XORed with the key matrix, reversing the XOR applied during encryption.
-   **Inverse S-Box Substitution**: The inverse S-Box is applied to restore the original byte values.
-   **Reconstruction**: The 3D matrix is flattened back into plaintext.

Role of Key Matrix
------------------

-   **Key Recovery**: The same sequence of keys is used as in encryption, but in reverse order.
-   **Evolution through Hashing**: The key evolves through each round of encryption and decryption via the SHA-256 hashing process, ensuring the key sequence matches the encryption process.